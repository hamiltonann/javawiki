#summary 快速使用Spring開發.
#labels Featured,Phase-Implementation
<wiki:toc max_depth="3" />
說實在的，Spring框架是非常強大的工具，但是從入門到精通，實在是要花不少時
間，長久寫下來，由其在Web開發上，其實就是那一套加加減減，每個專案都要先
花一段時間，先把基本架構Copy & Paste出來。<br/>
所以我才想說乾脆大雜燴一番，把整隻章魚端出來，然後再把不要的手腳砍掉，
把多餘的時間專注在專案本身。<br/>
專案的內容包括 Spring Web(RESTful),Spring Mobile，Spring Security
(資料庫驗證或是使用OpenId驗證),多國語言,JPA(Hibernate),單元測試，整合測試，
程式碼樣式檢查與程式品質檢驗。<br/>
  一般來說，我認為可以移除的部分包括Spring Mobile，多國語言，JPA(換上您自個兒習慣的ORM)。 
其它的部分，我則認為應該保留。

= 建立專案 =
最快的方法當然是從命令列開始：
{{{
mvn archetype:generate -DarchetypeRepository=http://gwtrepo.googlecode.com/svn/repo \
-DarchetypeGroupId=com.google.code \
-DarchetypeArtifactId=SpringWebStart \
-DarchetypeVersion=0.1
}}}
然後回達一些問題
{{{
Define value for property 'groupId': : <輸入群組識別,如：com.yourcompany>
Define value for property 'artifactId': : <輸入專案名稱,如：TestSpringWeb>
Define value for property 'version':  1.0-SNAPSHOT: : <輸入專案的版本，預設為 1.0-SNAPSHOT>
Define value for property 'package':  com.spring: : <輸入套件名稱，預設為群組識別,為方便以下說明，此處定為com.spring>
Confirm properties configuration:
Ｙ: :
}}}
然後建立專案(使用IDE的朋友可以參考最後的段落，使用[#NetBeans NetBeans]或是[#Eclipse Eclipse]來建立專案）
<br/>然後到Maven的安裝目錄，看一下mvn(或mvn.bat)內*MAVEN_OPTS的設定，考慮加大記憶體的使用如
{{{
MAVEN_OPTS='-Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m'
}}}
然後執行
{{{
mvn verify
}}}
就可以看到整個專案從compile到整合測試的所有階段,最後執行
{{{
mvn site
}}}
產出所有報表後的內容在 ./target/site目錄下。

= 快速開始 =
  # 套件目錄<b>com.spring.context</b>與<b>com.spring.controller</b>會自動掃瞄可自動建立的Bean，所以建議將公用程式放到Context套件下而將Spring Controller則放到controller套件下
  # 所有Spring設的的進入點在<b>ApplicationContext.java(applicationContext.xml)</b>，然後包入其它設定檔，例如要Security要使用OpenId而不是資料庫，請將import的<b>applicationContext-security.xml</b>換成<b>applicationContext-openid.xml</b>
  # 所有jsp檔案全放到 WEB-INF/view目錄下，如果要直接從網止列存取，請到<b>applicationContext-mvc.xml</b>內新增設定<b>mvc:view-controller</b>，並考慮是否在<b>applicationContext-security.xml</b>增加一個intercept-url做權限管控
  # 在pom.xml內加入您資料庫的函式參考，並開啟<b>applicationContext.xml</b>，修改 id="appProperies" 內所有JDBC與Hibernate的參數，以適用您的資料庫設定。
  # 因為此模版程式無法連結真實資料庫，所以內附了一個記憶體資料庫，您既然已使用了實體資料庫，所以可以把*applicationContext.xml的<b>jdbc:initialize-database</b>移除並刪除檔案realSchema.sql
  # 您所撰寫的JPA程式請放到 com.spring.modle 套件下，hibernate將自動掃瞄該目錄讀取JPA程式的ORM設定
  # <b>applicationContext-security.xml</b>內有一個<b>port-mappings</b>設定，開發測試時分別將http與ssl對應到8080與8443，真正上線時，必須視實際環境修改。另外有指定Port的檔案分別是<b>pom.xml</b>與<b>testng-integration.xml</b>
  # 在 test/java下撰寫您的單視測試程式與整合測試程式(Class須以Test開頭)，並將之加到<b>testng-unit.xml</b>與<b>testng-integration.xml</b>內(本來是可以自動掃瞄的，但是大型專案的測試有時會跑到睡著，所以設定檔讓我們彈性指定要測試的程式)

= SD4J資料存取說明 =
如果您看了DefaultController.java的源碼，您會發現我使用了[http://code.google.com/p/sd4j/ sd4j]，
那是我寫的另外一個專案，該專案的概念只有兩個，其中Manager主導商業方法並控制交易，也就是裡面一些明顯看起來是資料異動的函式，已經是Transationable，
而Dao則是真正主導資料存取，在程式中使用@DaoManager與＠Dao會自動進行注入([http://code.google.com/p/sd4j/ sd4j]要求環境中要存在一個
[http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/orm/jpa/JpaTransactionManager.html JpaTransactionManager]物件)。
使用方式如下：
{{{
    @DaoManager //自動注入
    private RepositoryManager<Member> memberManager;
}}}
若是您的自已要執行的商業方法(一般發生在特殊選取或是同時異動多個物件)，或是要有必要跨資料物件存取則自行繼承範例如下：
{{{
public class DetailManager extends AnnotatedRepositoryManager<Detail> {
  @Dao //自動注入
  private DaoRepository<Master> masterDao;
  
  public List<Deail> findByMyself(...){
    String da = this.getAliasName();
    String ma = masterDao.getAliasName();
    StringBuilder ql = new StringBuilder("SELECT DISTINCT ").append(da).append(" FROM ").
      append(ma.getEntityName()).append(" ").append(ma).append(" JOIN ").append(ma).append(".collectionDetail ").
      append(da).append(" WHERE ").append(ma).append(".field=?1 ....");
    return getDao().findListByQL(getDao().getClazz()，ql.toString()，參數);
  }
  
  @Transactional(propagation = Propagation.REQUIRED，rollbackFor = Exception.class)
  public int myCustomUpdate(....){
     int res = 0;
     for(Detail detail:findByCriteria("WHERE ....")){
       if(detail.xxx()){
          detail.getMaster.setXXX(...);
          masterDao.update(detail.getMaster());
          ...
          res ++;
       }
     }
     return res;
  }
}
}}}
如果您要採用自已的資料庫存取機制，則請移除pom.xml內的repositories段落與sd4j的dependency。<br/>
但是移除的同時，您也會發現失去一些便利，[http://code.google.com/p/sd4j/ sd4j]有DaoPropertyEditor與IntDaoPropertyEditor
幫忙把Table 為整數或字串primary key轉成ORM物件，DefaultController.userinfo()就是直接把Key值變成Member物件，而不是傳
回Key值後再去Lookup物件。

= 安全性問題 =
這是比較不好處理的議題，常常看到一些程式在每一支裡面都要放上身分檢查(包括我目前在維護的一些舊專案)，
而[http://static.springsource.org/spring-security/site/ Spring Security(S.S)]把我從這些Ugly Code解救出來，但是
Spring 本身已經有點難學了，更何況是Spring Security，早期版本的S.S叫做Acegi，其設定會讓人哭不出來，還好改名以後設定上簡化了不少，
雖說如此，但設定起來也有點不容易，基本上我的設定已經考慮到大部分Web的使用情況，所以我會從說明如何快速設定後再來說明一些細節。
== 快速設定 ==
S.S的管控目標是URL,而人員管控則採用Role Base，相關設定參考applicationContext-security.xml，
例如我會設定 /admin/**只有ROLE_ADMIN(S.S習慣把角色命名為ROLE_XXXX)，可以進入，所以我設定
{{{
<intercept-url pattern="/admin/**" access="(hasIpAddress('192.168.0.0/16') or hasIpAddress('127.0.0.1')) and hasRole('ROLE_ADMIN')" requires-channel="any"/>
}}}
表示具有身分管理員的人在本機上或是公司內部的網路上才可使用 /admin/** 的網址，未登錄的人會導到登錄頁，而不符身分的人會接收到HTTP 403的訊息。
範例程式的登錄頁在 /WEB-INF/view/login.jsp，而所有安全性的錯誤全數導到同目錄的 error.jsp，請直接修改美化這兩頁的內容即可。
S.S的預設登錄路徑在 contextPath下的 /j_spring_security_check，而登出在 /j_spring_security_logout.
login.jsp的登錄頁有個選項：”_spring_security_remember_me“，勾選後會在該瀏覽器記錄該員資訊兩周，當登錄人員在二周內回來時，不用重新登錄就可取回
該員所有身分角色，但這裡有個例外，RemeberMe設定當遇到存取權限為"fullyAuthenticated" 或是 "IS_AUTHENTICATED_FULLY"時，要求必須是經過登錄驗證，
無法透過RemeberMe使用，像 /changePassword 就是這樣設定的，也就是必須直接登錄用戶才可使用。

因為不想讓用戶的帳號密碼在網路上明碼傳遞，所以我設定
{{{
<intercept-url pattern="/j_spring_security_check" access="permitAll" requires-channel="https"/>
}}}
請注意，這裡的requires-channel設定為https，所以若是form的Action採用的是http://localhost/xxx/j_spring_security_check 則會強制被轉址為http://localhost/xxx/j_spring_security_check，
但是S.S的登錄網址/j_spring_security_check被限定只接受POST method，而redirect使用的是GET method，所以我的Login.jsp內設定的是
{{{
  <form method="POST" action="https://..." >
    ...
}}}
才參避免產生錯誤。

另外一個議題是Session是在http連線或是https建立，其結果大不同。<br/>
SessionID記錄在Cookie的JSESSIONID內，若是Session在https://xxx/j_spring_security_check時才建立，
則JSESSIONID會成為Secured Cookie，表示只有在https連線,Cookie才會被送回主機；
若是Session建立於http連線，則http下建立的JSESSIONID Cookie，在SSL連線時時也會被送回，
亦即，若Session建立在https時只能在SSL連線下被看見，反之則不然，所以為了保持Sesson的一致，最好的方式就是在http下建立Session。

像範例程式，我希望SSL連線只用於帳號/密碼或是一些機密資料時使用，其它大多時候使用http連線，
好在jsp若是沒有設定session=false時，一般會建立Session，而且S.S的程式不會特地給login鏈結，只有在需要的時候，登錄頁才會出現，
大大避免Session建立在SSL下的機會。

至於一些靜態網頁，則一律不經過S.S，以減少處理的時間，例如：
{{{
    <http pattern="/images" security="none"/>
    <http pattern="/css" security="none"/>
    <http pattern="/scripts" security="none"/>
}}}
同時看一下web.xml的`<servlet-mapping`>設定，我把一些附檔名的連結處理全交給default servlet處理。

關於上述的access設定為什麼會有"fullyAuthenticated" 與 "IS_AUTHENTICATED_FULLY"呢？<br/>
那是因為後期的Spring採用的所謂的表達式語法(SpEL)，在設定上會比較彈性，分辨的方法是舊的設定採用全大寫，而SpEL則比較像是程式碼的片段。
相關的access設定請參考[http://static.springsource.org/spring-security/site/docs/3.1.x/reference/el-access.html#el-common-built-in 這裡]
與[http://grails-plugins.github.com/grails-spring-security-core/docs/manual/guide/5%20Configuring%20Request%20Mappings%20to%20Secure%20URLs.html這裡]。

== Session Fixation ==
首先要說明JSP的一個弱點[http://knowledge.twisc.ntust.edu.tw/doku.php?id=3%E4%BC%BA%E6%9C%8D%E7%AB%AF%E5%AE%89%E5%85%A8:3-2%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E5%BC%B1%E9%BB%9E:session%E5%9B%BA%E5%AE%9A%E6%94%BB%E6%93%8A Session Fixation]，
[http://en.wikipedia.org/wiki/Session_fixation Session Fixation]源起於JSESSIONID曝露在URL內，所以我們首先必須把`<http`>的屬性 disable-url-rewriting 設為 true
以防止URL rewrite把;jsessionid加掛到網址列。

另外S.S為了防止[http://static.springsource.org/spring-security/site/docs/3.1.x/reference/ns-config.html#ns-session-fixation Session Fixation]
也建議將`<session-management`>的session-fixation-protection設為migrateSession(預設，每次登錄後重建一個新的Session並抄錄將舊Session的內容)
或是newSession(每次登錄後重建一個新的Session)，但是因為範例程式的登錄是在SSL下進行，若是登錄後重建一個新的Session，那麼回到http時，
將因為無法看到Secuired Cookie，而jsp又會重新在http重建一個新Session，產生新的JSESSIONID去覆蓋SSL下產生的Secured同名Cookid，因而導致
SSL登錄的資訊完全遺失，為了上述所說SSL登錄所產生的Session丟失問題，所以只好𢖫痛將之設為"none"。

為了解決這個問題，可以改採登錄OpenId的方式，用http轉到OpenID網站，在這台OpenID主機完全使用SSL連線，然後用http回到Web Site, 
當然機密資訊仍用SSL，但是因為沒有登錄的問題，不會有Sesson重建覆蓋的問題產生。

通常一個企業內不時會新增一些系統，所以我另外寫了一個[http://code.google.com/p/oisso/ OpenID半成品]的專案，
並依我所服務的公司的狀況改寫並應用。如果您不需要，可將範例程式看到OpenId名稱的檔案全數移除。

== Ajax安全性 ==
當存取的網址須登錄或是沒有存取權限時，S.S會把網頁導到登錄頁或是錯誤頁，但顯然在Ajax這是行不通的。<br/>
所以有預設放了一支程式AjaxAwareLoginUrlAuthenticationEntryPoint.java針對明確是使用Ajax進入或是路徑包含了/json的網址視為Ajax存取，直接回應錯誤，
如果您有其它的考量，請自行修改這支程式。
= Controller使用參數 =
如果您看了DefaultController，您會發現每個Spring的Controller不會像Struts那樣需要一個execute(mapping,form,request,response)，
基本上函式名稱隨便自已取，[http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments 參數]隨便放
(因為範例使用的Spring Mobile，所以可以多放一個Device參數)，Spring叫用時，會自個把該填的參數自已填上去，且
[http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-return-types 回傳值]也可自行決定(多半是String)。<br/>
另外，如何放一些我們自個兒的參數？<br/>

= 以IDE建立專案 =
== NetBeans ==
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarch1.png" alt="開啟新專案" title="開啟新專案"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarch2.png" alt="填入Archetype資訊" title="填入Archetype資訊"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarch3.png" alt="填入專案資訊" title="填入專案資訊"/></div>
然後建立專案
== Eclipse ==
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche1.png" alt="開啟新專案" title="開啟新專案"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche2.png" alt="選擇專案位置" title="選擇專案位置"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche3.png" alt="加入Archetype" title="加入Archetype"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche4.png" alt="填入Archetype資訊" title="填入Archetype資訊"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche5.png" alt="選擇Archetype" title="選擇Archetype"/></div>
<div><img src="http://javawiki.googlecode.com/svn/images/mavenarche6.png" alt="填入專案資訊" title="填入專案資訊"/></div>
然後建立專案
　